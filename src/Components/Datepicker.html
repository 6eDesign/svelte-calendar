<div class="datepicker" class:open="isOpen" class:closing="isClosing">
  <Popover 
    ref:popover 
    bind:open="isOpen" 
    bind:shrink="isClosing"
    {trigger}
    on:opened="registerOpen(event)"
    on:closed="registerClose(event)"
  >
    <div slot="trigger">
      <slot>
        {#if !trigger}
          <button class="calendar-button">
            {formattedSelected}
          </button>
        {/if}
      </slot>
    </div>
    <div slot="contents">
      <div class="calendar">
        <NavBar 
          {month} 
          {year}
          {start}
          {end}
          {canIncrementMonth}
          {canDecrementMonth}
          on:monthSelected="changeMonth(event)" 
          on:incrementMonth="incrementMonth(event)"
        />
        <div class="legend">
          {#each dayDict as day}
            <span>{day.abbrev}</span>
          {/each}
        </div>
        <Month 
          {visibleMonth}
          {selected}
          {start}
          {end}
          on:dateSelected="registerSelection(event)"
        />
      </div>
    </div>
  </Popover>
</div>

<style>

  .datepicker { 
    display: inline-block;
    margin: 0 auto;
    text-align: center;
    overflow: visible;
  }

  /* 

  A curtain/blackout div which focuses attention on the calendar 
  and highlights the areas that can be clicked to close the calendar

  .datepicker:before { 
    content: '';
    visibility: hidden;
    position: fixed;
    top: 0; 
    left: 0; 
    width: 100vw; 
    height: 100vh;
    background: rgba(0,0,0,0.3);
    opacity: 0; 
    transition: all 231ms linear;
    z-index: 1;
  }

  .datepicker.open:before { 
    visibility: visible;
    opacity: 1; 
  }

  .datepicker.closing:before { 
    visibility: hidden;
    opacity: 0; 
  } 
  
  */

  .calendar-button { 
    padding: 10px 20px;
    border: 1px solid #eee;
    display: block;
    text-align: center;
    width: 300px;
    text-decoration: none;
    cursor: pointer;
    background: #fff;
    border-radius: 7px;
    box-shadow: 0px 0px 3px rgba(0,0,0,0.1);
  }

  html {
    box-sizing: border-box;
  }
  
  *, *:before, *:after {
    box-sizing: inherit;
  }
  
  .weeks-container { 
    height: 311px;
  }
  
  .calendar { 
    box-sizing: border-box;
    position: relative;
    overflow: hidden;
    user-select: none;
    width: 100vw;
    padding: 10px;
    padding-top: 0; 
  }
  
  @media (min-width: 480px) { 
    .calendar { 
      height: auto; 
      width: 340px;
      max-width: 100%;
    }
  }
  
  .legend { 
    color: #4a4a4a;
    padding: 10px 0;
    margin-bottom: 5px;
  }
  
  .legend span { 
    width: 14.285714%;
    display: inline-block;
    text-align: center;
  }

  .flex-container {
    padding: 0;
    margin: 0;
    list-style: none;
    display: -webkit-box;
    display: -moz-box;
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
    -webkit-flex-flow: row;
    justify-content: space-around;
    line-height:30px;
  }
  
  .flex-item {
    background: tomato;
    margin: 5px;
    color: white;
    font-weight: bold;
    text-align: center;
    font-size: 1.5em;
    flex: 1 0 auto;
    height:auto;
    display: flex; 
  }
  
  .flex-item:before {
    content:'';
    float:left;
    padding-top:100%;
  }
  
  .flex-item-inner { 
    display: flex;
    justify-content: center;
    flex-direction: column;
    width: 100%;
  }
</style>

<script>
  import { dayDict, monthDict } from './lib/dictionaries';
  import { getMonths } from './lib/helpers';
  import { formatDate } from 'timeUtils';
  import { keyCodes, keyCodesArray } from './lib/keyCodes';

  let today = new Date();
  today.setHours(0,0,0,0);
  
  export default { 
    data() { 
      let today = new Date(); 
      return { 
        today,
        dayDict,
        format: '#{m}/#{d}/#{Y}',
        start: new Date(1987, 9, 29), 
        end: new Date(2020, 9, 29),
        selected: today, 
        dateChosen: false,
        month: today.getMonth(), 
        year: today.getFullYear(), 
        trigger: null, 
        assignmentHandler(trigger,formatted) { 
          console.log('formatted');
          trigger.innerHTML = formatted;
        }
      }
    },
    computed: { 
      months: ({start, end}) => getMonths(start,end),
      monthIndex:  ({month,year,months}) => { 
        for(let i = 0; i < months.length; ++i) { 
          if(months[i].month == month && months[i].year == year) return i
        }
        return 0; 
      },
      visibleMonth: ({monthIndex, months}) => months[monthIndex],
      lastVisibleDate: ({visibleMonth}) => visibleMonth.weeks[visibleMonth.weeks.length-1].days[6].date,
      firstVisibleDate: ({visibleMonth}) => visibleMonth.weeks[0].days[0].date,
      canIncrementMonth: ({monthIndex,months}) => monthIndex < months.length -1,
      canDecrementMonth: ({monthIndex,months}) => monthIndex > 0,
      formattedSelected: ({selected,format}) => formatDate(selected,format), 
    },
    methods: { 
      changeMonth(month) { 
        this.set({month});
      },
      incrementMonth(direction,date) {
        let { canIncrementMonth, canDecrementMonth, month, year } = this.get(); 
        if(direction == 1 && !canIncrementMonth) return;
        if(direction == -1 && !canDecrementMonth) return;
        let current = new Date(year,month,1); 
        current.setMonth(current.getMonth() + direction); 
        month = current.getMonth(); 
        year = current.getFullYear(); 
        let selected = new Date(year, month, date || 1);
        this.set({
          selected,
          month,
          year
        });
      },
      incrementDay(amount) { 
        let { selected, visibleMonth, firstVisibleDate, lastVisibleDate } = this.get();
        selected = new Date(selected); 
        selected.setDate(selected.getDate() + amount); 
        if(amount > 0 && selected > lastVisibleDate) return this.incrementMonth(1,selected.getDate()); 
        if(amount < 0 && selected < firstVisibleDate) return this.incrementMonth(-1,selected.getDate());
        this.set({selected});
      }, 
      handleKeyPress(evt) { 
        if(keyCodesArray.indexOf(evt.keyCode) == -1) return; 
        evt.preventDefault(); 
        switch(evt.keyCode) { 
          case keyCodes.left:
            this.incrementDay(-1);
            break; 
          case keyCodes.up:
            this.incrementDay(-7);
            break; 
          case keyCodes.right:
            this.incrementDay(1);
            break; 
          case keyCodes.down:
            this.incrementDay(7);
            break; 
          case keyCodes.pgup:
            this.incrementMonth(-1);
            break;
          case keyCodes.pgdown:
            this.incrementMonth(1);
            break;
          case keyCodes.escape: 
          case keyCodes.enter:
            let { selected } = this.get(); 
            this.registerSelection(selected);
            break;
        }
      },
      registerSelection(selected) { 
        this.refs.popover.close(); 
        this.set({selected, dateChosen: true});
        let { trigger, formattedSelected } = this.get(); 
        this.assignValueToTrigger(trigger,formattedSelected); 
      },
      assignValueToTrigger(trigger,formatted) { 
        if(!trigger) return; 
        this.get().assignmentHandler(trigger,formatted);
      }, 
      registerOpen() { 
        let { selected } = this.get(); 
        let keydownListener = this.handleKeyPress.bind(this); 
        this.set({
          keydownListener, 
          month: selected.getMonth(), 
          year: selected.getFullYear()
        });
        document.addEventListener('keydown', keydownListener);
      }, 
      registerClose() { 
        let { keydownListener } = this.get(); 
        document.removeEventListener('keydown', keydownListener);
      }
    },
    oncreate() { 
      let { selected } = this.get(); 
      this.set({
        month: selected.getMonth(), 
        year: selected.getFullYear()
      });
    },
    components: { 
      Month: './Month.html',
      NavBar: './NavBar.html',
      Popover: './Popover.html'
    }
  }
</script>
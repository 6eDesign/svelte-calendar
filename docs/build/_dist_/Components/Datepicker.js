import './Datepicker.css.proxy.js';
/* src/Components/Datepicker.svelte generated by Svelte v3.29.4 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	create_component,
	create_slot,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	set_data,
	space,
	text,
	toggle_class,
	transition_in,
	transition_out,
	update_slot
} from "../../web_modules/svelte/internal.js";

import Month from "./Month.js";
import NavBar from "./NavBar.js";
import Popover from "./Popover.js";
import { getMonths } from "./lib/helpers.js";
import { formatDate, internationalize } from "../../web_modules/timeUtils.js";
import { keyCodes, keyCodesArray } from "./lib/keyCodes.js";
import { onMount, createEventDispatcher } from "../../web_modules/svelte.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[63] = list[i];
	return child_ctx;
}

const get_default_slot_changes = dirty => ({
	selected: dirty[0] & /*selected*/ 1,
	formattedSelected: dirty[0] & /*formattedSelected*/ 4
});

const get_default_slot_context = ctx => ({
	selected: /*selected*/ ctx[0],
	formattedSelected: /*formattedSelected*/ ctx[2]
});

// (277:8) {#if !trigger}
function create_if_block(ctx) {
	let button;
	let t;

	return {
		c() {
			button = element("button");
			t = text(/*formattedSelected*/ ctx[2]);
			attr(button, "class", "calendar-button svelte-1lorc63");
			attr(button, "type", "button");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*formattedSelected*/ 4) set_data(t, /*formattedSelected*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (276:43)          
function fallback_block(ctx) {
	let if_block_anchor;
	let if_block = !/*trigger*/ ctx[1] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (!/*trigger*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (275:4) <div slot="trigger">
function create_trigger_slot(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[38].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[45], get_default_slot_context);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	return {
		c() {
			div = element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(div, "slot", "trigger");
			attr(div, "class", "svelte-1lorc63");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*selected, formattedSelected*/ 5 | dirty[1] & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[45], dirty, get_default_slot_changes, get_default_slot_context);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty[0] & /*formattedSelected, trigger*/ 6) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (298:10) {#each sortedDaysOfWeek as day}
function create_each_block(ctx) {
	let span;
	let t_value = /*day*/ ctx[63][1] + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			attr(span, "class", "svelte-1lorc63");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (284:4) <div slot="contents">
function create_contents_slot(ctx) {
	let div0;
	let div2;
	let navbar;
	let t0;
	let div1;
	let t1;
	let month_1;
	let current;

	navbar = new NavBar({
			props: {
				month: /*month*/ ctx[9],
				year: /*year*/ ctx[10],
				canIncrementMonth: /*canIncrementMonth*/ ctx[15],
				canDecrementMonth: /*canDecrementMonth*/ ctx[16],
				start: /*start*/ ctx[3],
				end: /*end*/ ctx[4],
				monthsOfYear: /*monthsOfYear*/ ctx[5]
			}
		});

	navbar.$on("monthSelected", /*monthSelected_handler*/ ctx[39]);
	navbar.$on("incrementMonth", /*incrementMonth_handler*/ ctx[40]);
	let each_value = /*sortedDaysOfWeek*/ ctx[18];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	month_1 = new Month({
			props: {
				visibleMonth: /*visibleMonth*/ ctx[13],
				selected: /*selected*/ ctx[0],
				highlighted: /*highlighted*/ ctx[7],
				shouldShakeDate: /*shouldShakeDate*/ ctx[8],
				id: /*visibleMonthId*/ ctx[14]
			}
		});

	month_1.$on("dateSelected", /*dateSelected_handler*/ ctx[41]);

	return {
		c() {
			div0 = element("div");
			div2 = element("div");
			create_component(navbar.$$.fragment);
			t0 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			create_component(month_1.$$.fragment);
			attr(div1, "class", "legend svelte-1lorc63");
			attr(div2, "class", "calendar svelte-1lorc63");
			attr(div0, "slot", "contents");
			attr(div0, "class", "svelte-1lorc63");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, div2);
			mount_component(navbar, div2, null);
			append(div2, t0);
			append(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div2, t1);
			mount_component(month_1, div2, null);
			current = true;
		},
		p(ctx, dirty) {
			const navbar_changes = {};
			if (dirty[0] & /*month*/ 512) navbar_changes.month = /*month*/ ctx[9];
			if (dirty[0] & /*year*/ 1024) navbar_changes.year = /*year*/ ctx[10];
			if (dirty[0] & /*canIncrementMonth*/ 32768) navbar_changes.canIncrementMonth = /*canIncrementMonth*/ ctx[15];
			if (dirty[0] & /*canDecrementMonth*/ 65536) navbar_changes.canDecrementMonth = /*canDecrementMonth*/ ctx[16];
			if (dirty[0] & /*start*/ 8) navbar_changes.start = /*start*/ ctx[3];
			if (dirty[0] & /*end*/ 16) navbar_changes.end = /*end*/ ctx[4];
			if (dirty[0] & /*monthsOfYear*/ 32) navbar_changes.monthsOfYear = /*monthsOfYear*/ ctx[5];
			navbar.$set(navbar_changes);

			if (dirty[0] & /*sortedDaysOfWeek*/ 262144) {
				each_value = /*sortedDaysOfWeek*/ ctx[18];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			const month_1_changes = {};
			if (dirty[0] & /*visibleMonth*/ 8192) month_1_changes.visibleMonth = /*visibleMonth*/ ctx[13];
			if (dirty[0] & /*selected*/ 1) month_1_changes.selected = /*selected*/ ctx[0];
			if (dirty[0] & /*highlighted*/ 128) month_1_changes.highlighted = /*highlighted*/ ctx[7];
			if (dirty[0] & /*shouldShakeDate*/ 256) month_1_changes.shouldShakeDate = /*shouldShakeDate*/ ctx[8];
			if (dirty[0] & /*visibleMonthId*/ 16384) month_1_changes.id = /*visibleMonthId*/ ctx[14];
			month_1.$set(month_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(navbar.$$.fragment, local);
			transition_in(month_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(navbar.$$.fragment, local);
			transition_out(month_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			destroy_component(navbar);
			destroy_each(each_blocks, detaching);
			destroy_component(month_1);
		}
	};
}

// (267:2) <Popover     bind:this="{popover}"     bind:open="{isOpen}"     bind:shrink="{isClosing}"     {trigger}     on:opened="{registerOpen}"     on:closed="{registerClose}"   >
function create_default_slot(ctx) {
	let t;
	let current;

	return {
		c() {
			t = space();
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let popover_1;
	let updating_open;
	let updating_shrink;
	let current;

	function popover_1_open_binding(value) {
		/*popover_1_open_binding*/ ctx[43].call(null, value);
	}

	function popover_1_shrink_binding(value) {
		/*popover_1_shrink_binding*/ ctx[44].call(null, value);
	}

	let popover_1_props = {
		trigger: /*trigger*/ ctx[1],
		$$slots: {
			default: [create_default_slot],
			contents: [create_contents_slot],
			trigger: [create_trigger_slot]
		},
		$$scope: { ctx }
	};

	if (/*isOpen*/ ctx[11] !== void 0) {
		popover_1_props.open = /*isOpen*/ ctx[11];
	}

	if (/*isClosing*/ ctx[12] !== void 0) {
		popover_1_props.shrink = /*isClosing*/ ctx[12];
	}

	popover_1 = new Popover({ props: popover_1_props });
	/*popover_1_binding*/ ctx[42](popover_1);
	binding_callbacks.push(() => bind(popover_1, "open", popover_1_open_binding));
	binding_callbacks.push(() => bind(popover_1, "shrink", popover_1_shrink_binding));
	popover_1.$on("opened", /*registerOpen*/ ctx[23]);
	popover_1.$on("closed", /*registerClose*/ ctx[22]);

	return {
		c() {
			div = element("div");
			create_component(popover_1.$$.fragment);
			attr(div, "class", "datepicker svelte-1lorc63");
			attr(div, "style", /*wrapperStyle*/ ctx[17]);
			toggle_class(div, "open", /*isOpen*/ ctx[11]);
			toggle_class(div, "closing", /*isClosing*/ ctx[12]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(popover_1, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const popover_1_changes = {};
			if (dirty[0] & /*trigger*/ 2) popover_1_changes.trigger = /*trigger*/ ctx[1];

			if (dirty[0] & /*visibleMonth, selected, highlighted, shouldShakeDate, visibleMonthId, month, year, canIncrementMonth, canDecrementMonth, start, end, monthsOfYear, formattedSelected, trigger*/ 124863 | dirty[1] & /*$$scope*/ 16384) {
				popover_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_open && dirty[0] & /*isOpen*/ 2048) {
				updating_open = true;
				popover_1_changes.open = /*isOpen*/ ctx[11];
				add_flush_callback(() => updating_open = false);
			}

			if (!updating_shrink && dirty[0] & /*isClosing*/ 4096) {
				updating_shrink = true;
				popover_1_changes.shrink = /*isClosing*/ ctx[12];
				add_flush_callback(() => updating_shrink = false);
			}

			popover_1.$set(popover_1_changes);

			if (!current || dirty[0] & /*wrapperStyle*/ 131072) {
				attr(div, "style", /*wrapperStyle*/ ctx[17]);
			}

			if (dirty[0] & /*isOpen*/ 2048) {
				toggle_class(div, "open", /*isOpen*/ ctx[11]);
			}

			if (dirty[0] & /*isClosing*/ 4096) {
				toggle_class(div, "closing", /*isClosing*/ ctx[12]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(popover_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(popover_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*popover_1_binding*/ ctx[42](null);
			destroy_component(popover_1);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = createEventDispatcher();
	const today = new Date();
	const oneYear = 1000 * 60 * 60 * 24 * 365;
	let popover;
	let { format = "#{m}/#{d}/#{Y}" } = $$props;
	let { start = new Date(Date.now() - oneYear) } = $$props;
	let { end = new Date(Date.now() + oneYear) } = $$props;
	let { selected = today } = $$props;
	let { dateChosen = false } = $$props;
	let { trigger = null } = $$props;
	let { selectableCallback = null } = $$props;
	let { weekStart = 0 } = $$props;

	let { daysOfWeek = [
		["Sunday", "Sun"],
		["Monday", "Mon"],
		["Tuesday", "Tue"],
		["Wednesday", "Wed"],
		["Thursday", "Thu"],
		["Friday", "Fri"],
		["Saturday", "Sat"]
	] } = $$props;

	let { monthsOfYear = [
		["January", "Jan"],
		["February", "Feb"],
		["March", "Mar"],
		["April", "Apr"],
		["May", "May"],
		["June", "Jun"],
		["July", "Jul"],
		["August", "Aug"],
		["September", "Sep"],
		["October", "Oct"],
		["November", "Nov"],
		["December", "Dec"]
	] } = $$props;

	selected = selected.getTime() < start.getTime() || selected.getTime() > end.getTime()
	? start
	: selected;

	let { style = "" } = $$props;
	let { buttonBackgroundColor = "#fff" } = $$props;
	let { buttonBorderColor = "#eee" } = $$props;
	let { buttonTextColor = "#333" } = $$props;
	let { highlightColor = "#f7901e" } = $$props;
	let { dayBackgroundColor = "none" } = $$props;
	let { dayTextColor = "#4a4a4a" } = $$props;
	let { dayHighlightedBackgroundColor = "#efefef" } = $$props;
	let { dayHighlightedTextColor = "#4a4a4a" } = $$props;
	internationalize({ daysOfWeek, monthsOfYear });

	let sortedDaysOfWeek = weekStart === 0
	? daysOfWeek
	: (() => {
			let dow = daysOfWeek.slice();
			dow.push(dow.shift());
			return dow;
		})();

	let highlighted = today;
	let shouldShakeDate = false;
	let shakeHighlightTimeout;
	let month = today.getMonth();
	let year = today.getFullYear();
	let isOpen = false;
	let isClosing = false;
	today.setHours(0, 0, 0, 0);

	function assignmentHandler(formatted) {
		if (!trigger) return;
		$$invalidate(1, trigger.innerHTML = formatted, trigger);
	}

	let monthIndex = 0;
	let { formattedSelected } = $$props;

	onMount(() => {
		$$invalidate(9, month = selected.getMonth());
		$$invalidate(10, year = selected.getFullYear());
	});

	function changeMonth(selectedMonth) {
		$$invalidate(9, month = selectedMonth);
		$$invalidate(7, highlighted = new Date(year, month, 1));
	}

	function incrementMonth(direction, day = 1) {
		if (direction === 1 && !canIncrementMonth) return;
		if (direction === -1 && !canDecrementMonth) return;
		let current = new Date(year, month, 1);
		current.setMonth(current.getMonth() + direction);
		$$invalidate(9, month = current.getMonth());
		$$invalidate(10, year = current.getFullYear());
		$$invalidate(7, highlighted = new Date(year, month, day));
	}

	function getDefaultHighlighted() {
		return new Date(selected);
	}

	const getDay = (m, d, y) => {
		let theMonth = months.find(aMonth => aMonth.month === m && aMonth.year === y);
		if (!theMonth) return null;

		// eslint-disable-next-line
		for (let i = 0; i < theMonth.weeks.length; ++i) {
			// eslint-disable-next-line
			for (let j = 0; j < theMonth.weeks[i].days.length; ++j) {
				let aDay = theMonth.weeks[i].days[j];
				if (aDay.month === m && aDay.day === d && aDay.year === y) return aDay;
			}
		}

		return null;
	};

	function incrementDayHighlighted(amount) {
		let proposedDate = new Date(highlighted);
		proposedDate.setDate(highlighted.getDate() + amount);
		let correspondingDayObj = getDay(proposedDate.getMonth(), proposedDate.getDate(), proposedDate.getFullYear());
		if (!correspondingDayObj || !correspondingDayObj.isInRange) return;
		$$invalidate(7, highlighted = proposedDate);

		if (amount > 0 && highlighted > lastVisibleDate) {
			incrementMonth(1, highlighted.getDate());
		}

		if (amount < 0 && highlighted < firstVisibleDate) {
			incrementMonth(-1, highlighted.getDate());
		}
	}

	function checkIfVisibleDateIsSelectable(date) {
		const proposedDay = getDay(date.getMonth(), date.getDate(), date.getFullYear());
		return proposedDay && proposedDay.selectable;
	}

	function shakeDate(date) {
		clearTimeout(shakeHighlightTimeout);
		$$invalidate(8, shouldShakeDate = date);

		shakeHighlightTimeout = setTimeout(
			() => {
				$$invalidate(8, shouldShakeDate = false);
			},
			700
		);
	}

	function assignValueToTrigger(formatted) {
		assignmentHandler(formatted);
	}

	function registerSelection(chosen) {
		if (!checkIfVisibleDateIsSelectable(chosen)) return shakeDate(chosen);

		// eslint-disable-next-line
		close();

		$$invalidate(0, selected = chosen);
		$$invalidate(24, dateChosen = true);
		assignValueToTrigger(formattedSelected);
		return dispatch("dateSelected", { date: chosen });
	}

	function handleKeyPress(evt) {
		if (keyCodesArray.indexOf(evt.keyCode) === -1) return;
		evt.preventDefault();

		switch (evt.keyCode) {
			case keyCodes.left:
				incrementDayHighlighted(-1);
				break;
			case keyCodes.up:
				incrementDayHighlighted(-7);
				break;
			case keyCodes.right:
				incrementDayHighlighted(1);
				break;
			case keyCodes.down:
				incrementDayHighlighted(7);
				break;
			case keyCodes.pgup:
				incrementMonth(-1);
				break;
			case keyCodes.pgdown:
				incrementMonth(1);
				break;
			case keyCodes.escape:
				// eslint-disable-next-line
				close();
				break;
			case keyCodes.enter:
				registerSelection(highlighted);
				break;
			default:
				break;
		}
	}

	function registerClose() {
		document.removeEventListener("keydown", handleKeyPress);
		dispatch("close");
	}

	function close() {
		popover.close();
		registerClose();
	}

	function registerOpen() {
		$$invalidate(7, highlighted = getDefaultHighlighted());
		$$invalidate(9, month = selected.getMonth());
		$$invalidate(10, year = selected.getFullYear());
		document.addEventListener("keydown", handleKeyPress);
		dispatch("open");
	}

	const monthSelected_handler = e => changeMonth(e.detail);
	const incrementMonth_handler = e => incrementMonth(e.detail);
	const dateSelected_handler = e => registerSelection(e.detail);

	function popover_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			popover = $$value;
			$$invalidate(6, popover);
		});
	}

	function popover_1_open_binding(value) {
		isOpen = value;
		$$invalidate(11, isOpen);
	}

	function popover_1_shrink_binding(value) {
		isClosing = value;
		$$invalidate(12, isClosing);
	}

	$$self.$$set = $$props => {
		if ("format" in $$props) $$invalidate(25, format = $$props.format);
		if ("start" in $$props) $$invalidate(3, start = $$props.start);
		if ("end" in $$props) $$invalidate(4, end = $$props.end);
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
		if ("dateChosen" in $$props) $$invalidate(24, dateChosen = $$props.dateChosen);
		if ("trigger" in $$props) $$invalidate(1, trigger = $$props.trigger);
		if ("selectableCallback" in $$props) $$invalidate(26, selectableCallback = $$props.selectableCallback);
		if ("weekStart" in $$props) $$invalidate(27, weekStart = $$props.weekStart);
		if ("daysOfWeek" in $$props) $$invalidate(28, daysOfWeek = $$props.daysOfWeek);
		if ("monthsOfYear" in $$props) $$invalidate(5, monthsOfYear = $$props.monthsOfYear);
		if ("style" in $$props) $$invalidate(29, style = $$props.style);
		if ("buttonBackgroundColor" in $$props) $$invalidate(30, buttonBackgroundColor = $$props.buttonBackgroundColor);
		if ("buttonBorderColor" in $$props) $$invalidate(31, buttonBorderColor = $$props.buttonBorderColor);
		if ("buttonTextColor" in $$props) $$invalidate(32, buttonTextColor = $$props.buttonTextColor);
		if ("highlightColor" in $$props) $$invalidate(33, highlightColor = $$props.highlightColor);
		if ("dayBackgroundColor" in $$props) $$invalidate(34, dayBackgroundColor = $$props.dayBackgroundColor);
		if ("dayTextColor" in $$props) $$invalidate(35, dayTextColor = $$props.dayTextColor);
		if ("dayHighlightedBackgroundColor" in $$props) $$invalidate(36, dayHighlightedBackgroundColor = $$props.dayHighlightedBackgroundColor);
		if ("dayHighlightedTextColor" in $$props) $$invalidate(37, dayHighlightedTextColor = $$props.dayHighlightedTextColor);
		if ("formattedSelected" in $$props) $$invalidate(2, formattedSelected = $$props.formattedSelected);
		if ("$$scope" in $$props) $$invalidate(45, $$scope = $$props.$$scope);
	};

	let months;
	let visibleMonth;
	let visibleMonthId;
	let lastVisibleDate;
	let firstVisibleDate;
	let canIncrementMonth;
	let canDecrementMonth;
	let wrapperStyle;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*start, end, selectableCallback, weekStart*/ 201326616) {
			$: $$invalidate(48, months = getMonths(start, end, selectableCallback, weekStart));
		}

		if ($$self.$$.dirty[0] & /*month, year*/ 1536 | $$self.$$.dirty[1] & /*months*/ 131072) {
			$: {
				$$invalidate(47, monthIndex = 0);

				for (let i = 0; i < months.length; i += 1) {
					if (months[i].month === month && months[i].year === year) {
						$$invalidate(47, monthIndex = i);
					}
				}
			}
		}

		if ($$self.$$.dirty[1] & /*months, monthIndex*/ 196608) {
			$: $$invalidate(13, visibleMonth = months[monthIndex]);
		}

		if ($$self.$$.dirty[0] & /*year, month*/ 1536) {
			$: $$invalidate(14, visibleMonthId = year + month / 100);
		}

		if ($$self.$$.dirty[0] & /*visibleMonth*/ 8192) {
			$: lastVisibleDate = visibleMonth.weeks[visibleMonth.weeks.length - 1].days[6].date;
		}

		if ($$self.$$.dirty[0] & /*visibleMonth*/ 8192) {
			$: firstVisibleDate = visibleMonth.weeks[0].days[0].date;
		}

		if ($$self.$$.dirty[1] & /*monthIndex, months*/ 196608) {
			$: $$invalidate(15, canIncrementMonth = monthIndex < months.length - 1);
		}

		if ($$self.$$.dirty[1] & /*monthIndex*/ 65536) {
			$: $$invalidate(16, canDecrementMonth = monthIndex > 0);
		}

		if ($$self.$$.dirty[0] & /*buttonBackgroundColor, style*/ 1610612736 | $$self.$$.dirty[1] & /*buttonBorderColor, buttonTextColor, highlightColor, dayBackgroundColor, dayTextColor, dayHighlightedBackgroundColor, dayHighlightedTextColor*/ 127) {
			$: $$invalidate(17, wrapperStyle = `
    --button-background-color: ${buttonBackgroundColor};
    --button-border-color: ${buttonBorderColor};
    --button-text-color: ${buttonTextColor};
    --highlight-color: ${highlightColor};
    --day-background-color: ${dayBackgroundColor};
    --day-text-color: ${dayTextColor};
    --day-highlighted-background-color: ${dayHighlightedBackgroundColor};
    --day-highlighted-text-color: ${dayHighlightedTextColor};
    ${style}
  `);
		}

		if ($$self.$$.dirty[0] & /*format, selected*/ 33554433) {
			$: {
				$$invalidate(2, formattedSelected = typeof format === "function"
				? format(selected)
				: formatDate(selected, format));
			}
		}
	};

	return [
		selected,
		trigger,
		formattedSelected,
		start,
		end,
		monthsOfYear,
		popover,
		highlighted,
		shouldShakeDate,
		month,
		year,
		isOpen,
		isClosing,
		visibleMonth,
		visibleMonthId,
		canIncrementMonth,
		canDecrementMonth,
		wrapperStyle,
		sortedDaysOfWeek,
		changeMonth,
		incrementMonth,
		registerSelection,
		registerClose,
		registerOpen,
		dateChosen,
		format,
		selectableCallback,
		weekStart,
		daysOfWeek,
		style,
		buttonBackgroundColor,
		buttonBorderColor,
		buttonTextColor,
		highlightColor,
		dayBackgroundColor,
		dayTextColor,
		dayHighlightedBackgroundColor,
		dayHighlightedTextColor,
		slots,
		monthSelected_handler,
		incrementMonth_handler,
		dateSelected_handler,
		popover_1_binding,
		popover_1_open_binding,
		popover_1_shrink_binding,
		$$scope
	];
}

class Datepicker extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				format: 25,
				start: 3,
				end: 4,
				selected: 0,
				dateChosen: 24,
				trigger: 1,
				selectableCallback: 26,
				weekStart: 27,
				daysOfWeek: 28,
				monthsOfYear: 5,
				style: 29,
				buttonBackgroundColor: 30,
				buttonBorderColor: 31,
				buttonTextColor: 32,
				highlightColor: 33,
				dayBackgroundColor: 34,
				dayTextColor: 35,
				dayHighlightedBackgroundColor: 36,
				dayHighlightedTextColor: 37,
				formattedSelected: 2
			},
			[-1, -1, -1]
		);
	}
}

export default Datepicker;